- [[SEPM Module 4]]
# Syllabus
	- Planning phase – project planning objective, software scope, empirical estimation models- COCOMO, single variable model, staffing and personal planning. Design phase – design process, principles, concepts, effective modular design, top down, bottom up strategies, stepwise refinement
- Software Scope
	- It is the first step in project planning
	- It should have function and performance details which is unambiguous and understandable at management and technical levels
	- Software scope
		- describes the functions and feature that are delivered to the end user,
		- the data that are input and output,
		- the content presented to users as a consequence of using the software,
		- and the performance constraints and reliability that bound the systems.
	- Scope defined using 2 techniques
		- A narrative description of software scope is developed after communication with stakeholders
		- A set of use cases developed by the end users.
	- Once scope is understood, the dev team checks the viability of the project.
	- Project scope addresses the following
		- Function
			- The tasks that the software is expected to perform
		- Performance
			- Processing and response time required
		- Constraints
			- Limits placed over software like memory restriction
		- Interfaces
			- The interaction of the user with the software.
# Empirical Estimation Models
	- Size Estimation
		- Estimation of size is a critical and difficult part of project planning.
		- Difficulties lie in the fact that software is essentially an abstract.
		- **Lines of Code (LOC)**
			- A LOC is any line of program that is not a comment or blank line, regardless of the number of statements or fragments of statements on the line.
		- **Function Count**
			- It measures functionality from the users point of view.
			- It deals with the functionality being delivered and not the lines of code.
			- It is independent on the technology used to deliver functions.
	- Cost Estimation
		- Approximate judgement of the costs for a project. It should be done throughout the entire life cycle.
		- Why we need cost estimation?
			- To determine how much effort and time the software project needs.
			- Important for making good management decisions
			- It facilitates competitive bids.
			- It affects the planning and budgeting of the project.
	- Three main approaches to estimation
		- Empirical Techniques
			- An educated guess based on past experience
		- Heuristic Techniques
			- The characteristics to be estimated are expressed in terms of a mathematical expression.
		- Analytical Techniques
			- derive the required results starting from simple assumptions
	- Cost Estimation Models
		- Estimation is the process of finding an estimate or approximation, which is a value that can be used for some purpose even if the input data is incomplete, uncertain or unstable.
		- Estimation determines how much money, effort, resources and time it will take to build a specific system or product.
		- Estimation Models use derived formulas to predict effort as a function of LOC.
		- In these models, the software project is represented in terms of effort required to develop it successfully.
		- Cost Estimation Models classified into two models
			- Algorithmic Models
				- Estimations in these models are based on mathematical equations which are based on historic data or thoery
				- Types are :
					- COCOMO
					- COCOMO II
					- Software Equation
			- Non Algorithmic Models
				- Estimation on these models depends on the prior experience and domain knowledge of project managers.
				- They do not use mathematical equations rather use expert judgement or estimation by analogy, etc.
	- Empirical Estimation Model
		- The structure of empirical estimation models is a formula,
			- derived from data collected from past projects
			- that uses software size to estimate effort. Effort itself is an estimate described either as LOC or FC.
		- No estimation model is appropriate for all development environments, development processes or application types.
		  Models must be customized based on data from the particular environment.
			- E = a + b (S) c
			- E : Effort (in person months). Amount of labor that will be required to complete the task, measured in person-months units.
			- S : size in LOC or FC.
			- a, b, c : values derived from the project environment
	- Static, Single variable models
		- This model use an equation to estimate the desired values such as cost, time, effort, etc.
		- C = a L ^b
			- C : cost
			- L : size in lines of code in thousand lines
			- a, b : constants
		- E = 1.4 L ^ 0.93
			- E : effort in person-months
		- DOC = 30.4 L ^ 0.90
		- D = 4.6 L 0.26
	- COCOMO Model
		- It is a single variable software cost estimation model developed by Barry Boehm.
		- It uses basic regression formula with parameters that are derived from historical project data and current project characteristics.
		- Divides software product development into 3 categories:
			- Organic : Relatively small groups, working to develop well understood applications
			- Semidetached : Project team consists of a mixture of experienced and inexperienced staff.
			- Embedded : The software is strongly coupled with complex hardware and real time systems.
		- COCOMO is applied to
			- Organic Mode
			- Semidetached Mode
			- Embedded Mode
		- For the 3 categories, for size estimation (in KLOC), Boehm provides equations to predict
			- project duration in months
			- effort in programmer-months
		- KLOC : size measured in term of thousand delivered lines of code
		- Software cost estimation done through three stages:
			- Basic COCOMO
			- Intermediate COCOMO
			- Complete COCOMO
# Software Design
	- What constitutes a well defined design class
		- Complete
			- Contains the complete encapsulation of all data and methods that exist for the class
		- Sufficient
			- Contains only those methods that are sufficient to achieve the goal of the class
		- Primitiveness
			- Each method focusses on accomplishing one service of the class
		- High Cohesion
			- The class has a small, focused set of responsibilities
		- Low Coupling
			- Dependence of classes is kept at a minimum
	- ## Modularity
		- A modular system consist of well defined manageable units with well defined interfaces among them
		- Modular design should
			- Reduce complexity
			- Facilitate change
			- Result in easier implementation
		- Functional interdependence is achieved by developing modules with single minded function
		- Properties
			- Well defined subsytem
			- well defined purpose
			- can be separately compiled and stored
			- can use other modules
			- should be easier to use than to build
			- simple from outside than the inside
		- Modularity
			- enhances design clarity
			- which eases implementation,
			- debugging,
			- testing,
			- documenting,
			- maintenance
		- Module Coupling
			- Coupling is the measure of interdependence between modules
			- Achieved by
				- controlling number of parameters passed among modules
				- avoid passing undesirable data to calling module
				- maintain parent child relationship between calling and called modules
				- pass data not control information
			- Types of coupling
				- Data coupling - shares data
				- stamp coupling - shares data structures
				- control coupling - shares control information (like flags)
				- common coupling - has shared data
				- content coupling - module A can change data of module B
		- Module Cohesion
			- Cohesion is a measure of the degree to which the elements of a module are functionally related.
			- Types of module cohesion
				- Functional cohesion
					- A and B are part of a single functional task
				- Sequential cohesion
					- Outputs of A are the inputs of B
				- Procedural cohesion
					- A and B perform different tasks but they have to be combined because there is a specific order in which the tasks are to be completed.
				- Temporal cohesion
					- tasks that are executed in the same time span
				- Logical cohesion
					- A and B are together because they belong to the same logical class of functions
				- Coincidental cohesion
					- little to no relationship to one another.
		- Relationship between cohesion and coupling
			- If software is not properly modularized, then a trivial enhancement or change will result in the death of the project.
			- Software should be modularized with a goal of high cohesion and low coupling.
	- ## Design Strategy
		- A good system design strategy is to organize the program modules in such a way that are easy to develop and later to change.
		- Preexisting code should be understood and broken down if needed.
		- New code should support the logic of the system
		- Bottom up design
			- Modules are collected together in the form of libraries
			- Libraries are then combined together.
			- Combining should be done carefully as if the assumptions go wrong, we then should redesign from the lower levels
		- Top Down Design
			- Starts by identifying the major modules of the systems.
			- Decompose those into their lower level modules and iterating until the desired level of details is achieved.
			- This is know step wise refinement.
			- Suitable if the specifications are clear and development is from scratch.
			- Disadvantage: can only be tested after all submodules are coded.
		- Hybrid Approach
			- Even though top down is more suited, some bottom up approach is desirable.
			- Bottom up permits common sub modules
			- reuse of modules